terraform plan -out tfplan
data.aws_availability_zones.available: Reading...
data.aws_ami.nat: Reading...
data.aws_availability_zones.available: Read complete after 1s [id=eu-north-1]
data.aws_ami.nat: Read complete after 1s [id=ami-02e4c7f8b323ecc06]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.bastion will be created
  + resource "aws_instance" "bastion" {
      + ami                                  = "ami-0914547665e6a707c"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = true
      + availability_zone                    = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + enable_primary_ipv6                  = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_lifecycle                   = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t3.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = "MyKeyPair"
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + region                               = "eu-north-1"
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + spot_instance_request_id             = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "task2-bastion"
        }
      + tags_all                             = {
          + "Name" = "task2-bastion"
        }
      + tenancy                              = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + instance_market_options (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

  # aws_instance.nat will be created
  + resource "aws_instance" "nat" {
      + ami                                  = "ami-02e4c7f8b323ecc06"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = true
      + availability_zone                    = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + enable_primary_ipv6                  = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_lifecycle                   = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t3.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = "MyKeyPair"
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + region                               = "eu-north-1"
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = false
      + spot_instance_request_id             = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "task2-nat"
        }
      + tags_all                             = {
          + "Name" = "task2-nat"
        }
      + tenancy                              = (known after apply)
      + user_data                            = <<-EOT
            #!/bin/bash
            # Включаем пересылку пакетов
            echo "net.ipv4.ip_forward=1" >> /etc/sysctl.d/90-nat.conf
            sysctl --system

            # Устанавливаем iptables-services
            yum install -y iptables-services

            # Ждём появления второго интерфейса (eth1)
            for i in {1..10}; do
              ETH1=\$(ip -4 addr show device-number-1 | grep -oP 'ens[0-9]+' | head -n1)
              [ -n "\$ETH1" ] && break
              sleep 3
            done

            # Определяем публичный интерфейс
            ETH0=\$(ip -4 addr show device-number-0 | grep -oP 'ens[0-9]+' | head -n1)

            # Настраиваем NAT в iptables
            iptables -t nat -A POSTROUTING -o \$ETH0 -j MASQUERADE
            iptables -A FORWARD -i \$ETH0 -o \$ETH1 -m state --state RELATED,ESTABLISHED -j ACCEPT
            iptables -A FORWARD -i \$ETH1 -o \$ETH0 -j ACCEPT

            # Сохраняем и запускаем iptables при загрузке
            systemctl enable iptables
            service iptables save
        EOT
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + instance_market_options (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

  # aws_internet_gateway.igw will be created
  + resource "aws_internet_gateway" "igw" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + region   = "eu-north-1"
      + tags     = {
          + "Name" = "task2-igw"
        }
      + tags_all = {
          + "Name" = "task2-igw"
        }
      + vpc_id   = (known after apply)
    }

  # aws_network_acl.private[0] will be created
  + resource "aws_network_acl" "private" {
      + arn        = (known after apply)
      + egress     = (known after apply)
      + id         = (known after apply)
      + ingress    = (known after apply)
      + owner_id   = (known after apply)
      + region     = "eu-north-1"
      + subnet_ids = (known after apply)
      + tags       = {
          + "Name" = "task2-private-nacl-0"
        }
      + tags_all   = {
          + "Name" = "task2-private-nacl-0"
        }
      + vpc_id     = (known after apply)
    }

  # aws_network_acl.private[1] will be created
  + resource "aws_network_acl" "private" {
      + arn        = (known after apply)
      + egress     = (known after apply)
      + id         = (known after apply)
      + ingress    = (known after apply)
      + owner_id   = (known after apply)
      + region     = "eu-north-1"
      + subnet_ids = (known after apply)
      + tags       = {
          + "Name" = "task2-private-nacl-1"
        }
      + tags_all   = {
          + "Name" = "task2-private-nacl-1"
        }
      + vpc_id     = (known after apply)
    }

  # aws_network_acl.public[0] will be created
  + resource "aws_network_acl" "public" {
      + arn        = (known after apply)
      + egress     = (known after apply)
      + id         = (known after apply)
      + ingress    = (known after apply)
      + owner_id   = (known after apply)
      + region     = "eu-north-1"
      + subnet_ids = (known after apply)
      + tags       = {
          + "Name" = "task2-public-nacl-0"
        }
      + tags_all   = {
          + "Name" = "task2-public-nacl-0"
        }
      + vpc_id     = (known after apply)
    }

  # aws_network_acl.public[1] will be created
  + resource "aws_network_acl" "public" {
      + arn        = (known after apply)
      + egress     = (known after apply)
      + id         = (known after apply)
      + ingress    = (known after apply)
      + owner_id   = (known after apply)
      + region     = "eu-north-1"
      + subnet_ids = (known after apply)
      + tags       = {
          + "Name" = "task2-public-nacl-1"
        }
      + tags_all   = {
          + "Name" = "task2-public-nacl-1"
        }
      + vpc_id     = (known after apply)
    }

  # aws_network_acl_rule.private_inbound_ephemeral_replies[0] will be created
  + resource "aws_network_acl_rule" "private_inbound_ephemeral_replies" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = false
      + from_port      = 1024
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "tcp"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 105
      + to_port        = 65535
    }

  # aws_network_acl_rule.private_inbound_ephemeral_replies[1] will be created
  + resource "aws_network_acl_rule" "private_inbound_ephemeral_replies" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = false
      + from_port      = 1024
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "tcp"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 105
      + to_port        = 65535
    }

  # aws_network_acl_rule.private_inbound_from_nat_subnet[0] will be created
  + resource "aws_network_acl_rule" "private_inbound_from_nat_subnet" {
      + cidr_block     = "10.0.1.0/24"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.private_inbound_from_nat_subnet[1] will be created
  + resource "aws_network_acl_rule" "private_inbound_from_nat_subnet" {
      + cidr_block     = "10.0.2.0/24"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.private_inbound_from_vpc[0] will be created
  + resource "aws_network_acl_rule" "private_inbound_from_vpc" {
      + cidr_block     = "10.0.0.0/16"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 110
      + to_port        = 0
    }

  # aws_network_acl_rule.private_inbound_from_vpc[1] will be created
  + resource "aws_network_acl_rule" "private_inbound_from_vpc" {
      + cidr_block     = "10.0.0.0/16"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 110
      + to_port        = 0
    }

  # aws_network_acl_rule.private_outbound[0] will be created
  + resource "aws_network_acl_rule" "private_outbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = true
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.private_outbound[1] will be created
  + resource "aws_network_acl_rule" "private_outbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = true
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.public_inbound[0] will be created
  + resource "aws_network_acl_rule" "public_inbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.public_inbound[1] will be created
  + resource "aws_network_acl_rule" "public_inbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = false
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.public_outbound[0] will be created
  + resource "aws_network_acl_rule" "public_outbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = true
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_network_acl_rule.public_outbound[1] will be created
  + resource "aws_network_acl_rule" "public_outbound" {
      + cidr_block     = "0.0.0.0/0"
      + egress         = true
      + from_port      = 0
      + id             = (known after apply)
      + network_acl_id = (known after apply)
      + protocol       = "-1"
      + region         = "eu-north-1"
      + rule_action    = "allow"
      + rule_number    = 100
      + to_port        = 0
    }

  # aws_route.private_default_via_nat will be created
  + resource "aws_route" "private_default_via_nat" {
      + destination_cidr_block = "0.0.0.0/0"
      + id                     = (known after apply)
      + instance_id            = (known after apply)
      + instance_owner_id      = (known after apply)
      + network_interface_id   = (known after apply)
      + origin                 = (known after apply)
      + region                 = "eu-north-1"
      + route_table_id         = (known after apply)
      + state                  = (known after apply)
    }

  # aws_route_table.private will be created
  + resource "aws_route_table" "private" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + region           = "eu-north-1"
      + route            = (known after apply)
      + tags             = {
          + "Name" = "task2-private-rt"
        }
      + tags_all         = {
          + "Name" = "task2-private-rt"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.public will be created
  + resource "aws_route_table" "public" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + region           = "eu-north-1"
      + route            = [
          + {
              + cidr_block                 = "0.0.0.0/0"
              + gateway_id                 = (known after apply)
                # (11 unchanged attributes hidden)
            },
        ]
      + tags             = {
          + "Name" = "task2-public-rt"
        }
      + tags_all         = {
          + "Name" = "task2-public-rt"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table_association.private[0] will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + region         = "eu-north-1"
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.private[1] will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + region         = "eu-north-1"
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public[0] will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + region         = "eu-north-1"
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public[1] will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + region         = "eu-north-1"
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_security_group.bastion_sg will be created
  + resource "aws_security_group" "bastion_sg" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 22
                # (1 unchanged attribute hidden)
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + region                 = "eu-north-1"
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "bastion-sg"
        }
      + tags_all               = {
          + "Name" = "bastion-sg"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group.nat_sg will be created
  + resource "aws_security_group" "nat_sg" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "10.0.101.0/24",
                  + "10.0.102.0/24",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 65535
                # (1 unchanged attribute hidden)
            },
          + {
              + cidr_blocks      = [
                  + "10.0.101.0/24",
                  + "10.0.102.0/24",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "udp"
              + security_groups  = []
              + self             = false
              + to_port          = 65535
                # (1 unchanged attribute hidden)
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + region                 = "eu-north-1"
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "task2-nat-sg"
        }
      + tags_all               = {
          + "Name" = "task2-nat-sg"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group.private_sg will be created
  + resource "aws_security_group" "private_sg" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = (known after apply)
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + region                 = "eu-north-1"
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "private-sg"
        }
      + tags_all               = {
          + "Name" = "private-sg"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group_rule.icmp_bastion_to_private will be created
  + resource "aws_security_group_rule" "icmp_bastion_to_private" {
      + from_port                = -1
      + id                       = (known after apply)
      + protocol                 = "icmp"
      + region                   = "eu-north-1"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = -1
      + type                     = "ingress"
    }

  # aws_security_group_rule.icmp_private_outbound will be created
  + resource "aws_security_group_rule" "icmp_private_outbound" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + from_port                = -1
      + id                       = (known after apply)
      + protocol                 = "icmp"
      + region                   = "eu-north-1"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = -1
      + type                     = "egress"
    }

  # aws_security_group_rule.ssh_bastion_to_private will be created
  + resource "aws_security_group_rule" "ssh_bastion_to_private" {
      + from_port                = 22
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + region                   = "eu-north-1"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 22
      + type                     = "ingress"
    }

  # aws_subnet.private[0] will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-north-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.101.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + region                                         = "eu-north-1"
      + tags                                           = {
          + "Name" = "task2-private-0"
        }
      + tags_all                                       = {
          + "Name" = "task2-private-0"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.private[1] will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-north-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.102.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + region                                         = "eu-north-1"
      + tags                                           = {
          + "Name" = "task2-private-1"
        }
      + tags_all                                       = {
          + "Name" = "task2-private-1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public[0] will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-north-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.1.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + region                                         = "eu-north-1"
      + tags                                           = {
          + "Name" = "task2-public-0"
        }
      + tags_all                                       = {
          + "Name" = "task2-public-0"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public[1] will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-north-1b"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.2.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + region                                         = "eu-north-1"
      + tags                                           = {
          + "Name" = "task2-public-1"
        }
      + tags_all                                       = {
          + "Name" = "task2-public-1"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_vpc.main will be created
  + resource "aws_vpc" "main" {
      + arn                                  = (known after apply)
      + cidr_block                           = "10.0.0.0/16"
      + default_network_acl_id               = (known after apply)
      + default_route_table_id               = (known after apply)
      + default_security_group_id            = (known after apply)
      + dhcp_options_id                      = (known after apply)
      + enable_dns_hostnames                 = true
      + enable_dns_support                   = true
      + enable_network_address_usage_metrics = (known after apply)
      + id                                   = (known after apply)
      + instance_tenancy                     = "default"
      + ipv6_association_id                  = (known after apply)
      + ipv6_cidr_block                      = (known after apply)
      + ipv6_cidr_block_network_border_group = (known after apply)
      + main_route_table_id                  = (known after apply)
      + owner_id                             = (known after apply)
      + region                               = "eu-north-1"
      + tags                                 = {
          + "Name" = "task2-vpc"
        }
      + tags_all                             = {
          + "Name" = "task2-vpc"
        }
    }

Plan: 37 to add, 0 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Saved the plan to: tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "tfplan"
